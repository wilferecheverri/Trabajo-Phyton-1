subo taller 1

{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "view-in-github"
   },
   "source": [
    "<a href=\"https://colab.research.google.com/github/elvoza/Curso-Introductorio-a-Python/blob/main/Sesi%C3%B3n_2.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "qS43xDWC6BES"
   },
   "source": [
    "<p><img alt=\"Colaboratory logo\" height=\"120px\" src=\"https://www.udea.edu.co/wps/wcm/connect/udea/df55724e-3ebc-46c6-b608-fb9206b3fede/facultad-economicas.png?MOD=AJPERES&CVID=nc5zPyj\" align=\"Center\" hspace=\"10px\" vspace=\"10px\"></p>\n",
    "\n",
    "#***Python I - Introducción a modelos económicos y financieros con Python***\n",
    "\n",
    "\n",
    "#**Sesión 2**\n",
    "# Docente: *Cristian Ruiz Parra*\n",
    "\n",
    "Contenido de la sesión\n",
    "\n",
    "- Indentación\n",
    "- Cadena de caracteres\n",
    "- Introducción a Numpy\n",
    "- Principales funciones\n",
    "- Taller practico Numpy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rGInSIpp63mw"
   },
   "source": [
    "# **Indentación (Sangria)**\n",
    "\n",
    "La indetación en Python es el espacio en blanco al inicio de cada linea de código que se usa para definir bloques de código; por ejemplo: En bucles for, condicionales if y funciones.\n",
    "\n",
    "La Convención utilizada son **4 espacios** y python entendera automaticamente que hace parte del ciclo o sentencia establecida (a partir del 1er espacio)\n",
    "\n",
    "Existe una regla no escrita de no mezclar tabs con espacios, para no generar inconsistencia en los metodos de indentación, sin embargo en el caso de google colaboratory, el tab tiene equivalencia automatica a **2 espacios** modificable a 4 en la pestaña de \"Herramientas\" en la función \"Configuración\" en la pestaña \"Editor\" se ajusta el ancho de la sangria"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "iXV9UK2O8Ixt"
   },
   "outputs": [],
   "source": [
    "edad=int(input(\"Inserte la edad de la persona:\"))\n",
    "\n",
    "if 0<=edad<=100: #Edad valida\n",
    "print(\"Edad valida\")\n",
    "if edad >= 18:\n",
    "print(\"Mayor de edad\")\n",
    "puede_votar = True\n",
    "else:\n",
    "print(\"Menor de edad\")\n",
    "puede_votar = False\n",
    "print(f\"Puede votar:{puede_votar}\")\n",
    "else:\n",
    "print(\"Edad invalida\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "5SFhSaKW5p2t"
   },
   "outputs": [],
   "source": [
    "edad=int(input(\"Inserte la edad de la persona:\"))\n",
    "\n",
    "if 0<=edad<=100: #Edad valida\n",
    "    print(\"Edad valida\")\n",
    "    if edad >= 18:\n",
    "        print(\"Mayor de edad\")\n",
    "        puede_votar = True\n",
    "    else:\n",
    "       print(\"Menor de edad\")\n",
    "       puede_votar = False\n",
    "\n",
    "    print(f\"Puede votar:{puede_votar}\")\n",
    "\n",
    "else:print(\"Edad invalida\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "KPZ_C-Rbbr0G"
   },
   "source": [
    "# **Cadenas de Caracteres (Strings)**\n",
    "Son secuencias de caracteres Unicode utilizadas para representar texto, los cuales son de los tipos de dados fundamentales y versatiles del lenguaje de programación"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "N7JW6iBvhClO"
   },
   "source": [
    "los caracteres especiales para definir en python un string son:\n",
    "\n",
    "Comillas simples:'Texto'\n",
    "\n",
    "Comillas dobles: \"Texto\"\n",
    "\n",
    "Comillas triples(tres comillas sencillas)\n",
    ":'''Texto'''\n",
    "\n",
    "Si se requiere usar alguno de los caracteres como parte del texto se usa alguna combinación de los anteriores\n",
    "\n",
    "Ejm:\n",
    "'ella dijo:\"Soy Feliz\"' de esta forma el definidor del string es la comilla simple(') y las comillas dobles(\") son parte del texto"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "a4SqFkGDccqW",
    "outputId": "f884996f-18c4-473a-d43e-9c6c83248a62"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hola querida María\n"
     ]
    }
   ],
   "source": [
    "# Comillas simples\n",
    "cadena1 = 'Hola querida'\n",
    "nombre = 'María'\n",
    "print(cadena1, nombre)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "oJkYoC0rcgYP",
    "outputId": "c297dafd-7d99-4bec-d4ae-525b9cbebb19"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Python \n",
      "es genia\n",
      "Él dijo: 'Hola'\n"
     ]
    }
   ],
   "source": [
    "# Comillas dobles\n",
    "cadena2 = \"Python es genial\"\n",
    "mensaje = \"Él dijo: 'Hola'\"\n",
    "print(cadena2)\n",
    "print(mensaje)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "4VQKApexcsDj",
    "outputId": "e00afd5d-b323-4329-a3ad-b7fed4377a77"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Este es un párrafo\n",
      "que ocupa múltiples líneas\n",
      "sin necesidad de caracteres especiales\n"
     ]
    }
   ],
   "source": [
    "# Comillas triples (multilínea)\n",
    "parrafo = \"\"\"Este es un párrafo\n",
    "que ocupa múltiples líneas\n",
    "sin necesidad de caracteres especiales\"\"\"\n",
    "print(parrafo)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "YwT-AqXaeRJ6"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Salto de línea:\n",
      "Línea 1\n",
      "Línea 2\n",
      "\n",
      "Tabulación:\n",
      "Nombre1:\tJuan\n",
      "Él dijo: \"Hola\"\n",
      "Número: ×\n"
     ]
    }
   ],
   "source": [
    "# Caracteres Especiales\n",
    "salto_linea = \"Línea 1\\nLínea 2\"           # \\n - Nueva línea\n",
    "tabulacion = \"Nombre1:\\tJuan\"              # \\t - Tabulación\n",
    "barra_invertida = \"Ruta: C:\\\\Usuarios\"     # \\\\ - Barra invertida\n",
    "comillas_dobles = 'Él dijo: \"Hola\"'        # \" dentro de '\n",
    "comillas_simples = \"It's amazing\"          # ' dentro de \"\n",
    "unicode_char = \"Número: \\u00D7\"            # \\u - Carácter Unicode\n",
    "\n",
    "print(\"Salto de línea:\")\n",
    "print(salto_linea)\n",
    "print(\"\\nTabulación:\")\n",
    "print(tabulacion)\n",
    "print(comillas_dobles)\n",
    "print(unicode_char)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "rm71jAJOC790"
   },
   "source": [
    "# **Indexación y corte de cadenas de texto**\n",
    "\n",
    "Para llamar un caracter especifico de la cadena de texto o para un segmento particular de la cadena usamos la misma estructura que se vimos anteriormente para las tuplas.\n",
    "Usando los enteros positivos para llamarlos de izquierda a derecha y los enteros negativos para llamarlos de derecha a izquierda(por tanto el -1 haria referencia al ultimo caracter)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "3py3DrCRroYT",
    "outputId": "c9147f61-e328-4d6f-a42a-0d2fa8a21835"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Texto: Python para todos\n",
      "Primer caracter: P\n",
      "Primeras 6 letras: Python\n",
      "Reverso: sodot arap nohtyP\n"
     ]
    }
   ],
   "source": [
    "texto = \"Python para todos\"\n",
    "\n",
    "# Indexación (acceso por posición)\n",
    "primer_caracter = texto[0]        # 'P'\n",
    "segundo_caracter = texto[1]       # 'y'\n",
    "ultimo_caracter = texto[-1]       # 's'\n",
    "penultimo = texto[-2]             # 'o'\n",
    "\n",
    "# Slicing (subcadenas)\n",
    "primeras_6 = texto[0:6]           # 'Python'\n",
    "desde_7 = texto[7:]               # 'para todos'\n",
    "hasta_10 = texto[:10]             # 'Python par'\n",
    "cada_2 = texto[::2]               # 'Pto pr ods'\n",
    "reverso = texto[::-1]             # 'sodot arap nohtyP'\n",
    "\n",
    "print(f\"Texto: {texto}\")\n",
    "print(f\"Primer caracter: {primer_caracter}\")\n",
    "print(f\"Segundo caracter: {segundo_caracter}\")\n",
    "print(f\"Último caracter: {ultimo_caracter}\")\n",
    "print(f\"Penúltimo caracter: {penultimo}\")\n",
    "print(f\"Primeras 6 letras: {primeras_6}\")\n",
    "print(f\"Desde el 7to caracter: {desde_7}\")\n",
    "print(f\"Hasta el 10mo caracter: {hasta_10}\")\n",
    "print(f\"Cada 2 caracteres: {cada_2}\")\n",
    "print(f\"Reverso: {reverso}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "QQU0F_gRt81V"
   },
   "source": [
    "# **Operaciones comunes con (Strings)**\n",
    "\n",
    "Tipos de operaciones:\n",
    "\n",
    "- Concatenación\n",
    "- Repetición\n",
    "- Longitud\n",
    "- membresia"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "_QsE5G6pxZhh"
   },
   "source": [
    "**Concatenación**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "AeN4phhPvN-D",
    "outputId": "6c78605c-0289-4a4d-a56e-df47d20c962a"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Ana García\n",
      "Hola estimada Ana García\n"
     ]
    }
   ],
   "source": [
    "# Concatenación (+)\n",
    "saludo = \"Hola\" + \" \" + \"estimada\"\n",
    "nombre_completo = \"Ana\" + \" \" + \"García\"\n",
    "Texto_completo=saludo+\" \"+nombre_completo\n",
    "print(nombre_completo)\n",
    "print(Texto_completo)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "5WcoxNOixhla",
    "outputId": "37a00db1-2684-4d06-b00c-ed4acb719c1a"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hola Mundo!\n"
     ]
    }
   ],
   "source": [
    "# Concatenación con atajo +=\n",
    "mensaje = \"Hola\"\n",
    "mensaje += \" Mundo\"               # \"Hola Mundo\"\n",
    "mensaje += \"!\"                    # \"Hola Mundo!\"\n",
    "print(mensaje)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "AZSOT0aPxsOA"
   },
   "source": [
    "**Repetición**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "28H1uCc6xv2s",
    "outputId": "b17ab243-6bdc-4784-cf79-26549d743713"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "¡Bravo! ¡Bravo! ¡Bravo! \n",
      "Ella----------------------------------------yo\n"
     ]
    }
   ],
   "source": [
    "# Repetición (*)\n",
    "aplausos = \"¡Bravo! \" * 3        # \"¡Bravo! ¡Bravo! ¡Bravo! \"\n",
    "\n",
    "separador = \"Ella\"+\"-\" * 40 + \"yo\"             # \"----------------------------------------\"\n",
    "print(aplausos)\n",
    "print(separador)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "G1NKdjVjyYLY"
   },
   "source": [
    "**Longitud**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "PQQtBDVDybS1",
    "outputId": "03a6fa22-78d4-460e-a51a-c1cbb0a484e5"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "'Aprendiendo Python' tiene 18 caracteres\n"
     ]
    }
   ],
   "source": [
    "texto = \"Aprendiendo Python\"\n",
    "\n",
    "# Longitud (len())\n",
    "longitud = len(texto)\n",
    "print(f\"'{texto}' tiene {longitud} caracteres\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "0vFvHsazypK4"
   },
   "source": [
    "**Membresia**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "swBcVUk4yrxX",
    "outputId": "92d00f19-d780-493d-9a19-6370aaf2c6ac"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "¿Contiene 'Python'? True\n",
      "¿Contiene 'Java'? False\n",
      "¿contiene 'PHP'?\n",
      "True\n"
     ]
    }
   ],
   "source": [
    "# Membresía (in, not in)\n",
    "contiene_python = \"Python\" in texto     # True\n",
    "contiene_java = \"Java\" in texto         # False\n",
    "no_contiene_php = \"PHP\" not in texto    # True\n",
    "\n",
    "print(f\"¿Contiene 'Python'? {contiene_python}\")\n",
    "print(f\"¿Contiene 'Java'? {contiene_java}\")\n",
    "print(\"¿contiene 'PHP'?\")\n",
    "print(contiene_python)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "s5Bb9KXM0lXk"
   },
   "source": [
    "# **Acciones principales**\n",
    "\n",
    "- Transformación de texto\n",
    "- Busqueda y verificación\n",
    "- División y Unión\n",
    "- Reemplazo y formateo\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "g9oiDzLo11of"
   },
   "source": [
    "**Transformación de texto**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "3TN4Aemr10y-",
    "outputId": "8babd1ef-ac08-414c-ac82-92ccfb4fb8ad"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Original: '  python es GENIAL  '\n",
      "Mayúsculas: '  PYTHON ES GENIAL  '\n",
      "Minúsculas: '  python es genial  '\n",
      "Título: '  Python Es Genial  '\n",
      "Strip: 'python es GENIAL'\n",
      "Lstrip: 'python es GENIAL  '\n",
      "Rstrip: '  python es GENIAL'\n",
      "replace:'pythonesGENIAL'\n"
     ]
    }
   ],
   "source": [
    "mensaje = \"  python es GENIAL  \"\n",
    "\n",
    "# Mayúsculas y minúsculas\n",
    "mayusculas = mensaje.upper()              # \"  PYTHON ES GENIAL  \"\n",
    "minusculas = mensaje.lower()              # \"  python es genial  \"\n",
    "titulo = mensaje.title()                  # \"  Python Es Genial  \"\n",
    "swapcase = \"PyThOn\".swapcase()            # \"pYtHoN\" Inverite patron\n",
    "\n",
    "# Eliminar espacios\n",
    "sin_espacios = mensaje.strip()            # \"python es GENIAL\"\n",
    "sin_izquierda = mensaje.lstrip()          # \"python es GENIAL  \"\n",
    "sin_derecha = mensaje.rstrip()            # \"  python es GENIAL\"\n",
    "sin_espaciosr=mensaje.replace(\" \",\"\")     # \"pythonesGENIAL\"\n",
    "\n",
    "\n",
    "# Reemplazar subcadenas\n",
    "print(f\"Original: '{mensaje}'\")\n",
    "print(f\"Mayúsculas: '{mayusculas}'\")\n",
    "print(f\"Minúsculas: '{minusculas}'\")\n",
    "print(f\"Título: '{titulo}'\")\n",
    "\n",
    "print(f\"Strip: '{sin_espacios}'\")\n",
    "print(f\"Lstrip: '{sin_izquierda}'\")\n",
    "print(f\"Rstrip: '{sin_derecha}'\")\n",
    "print(f\"replace:'{sin_espaciosr}'\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "P0XBk-oPMm4o"
   },
   "source": [
    "**Búsqueda y verificación**\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "BWzIUTkEMlyI",
    "outputId": "badd0efa-0392-4d48-eb7e-4ac59a1c57c6"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Posición de 'Programación': 19\n",
      "Última posición de 'n': 30\n",
      "Contador de 'n': 3\n",
      "¿Es alfanumérico? True\n",
      "¿Es alfabético? True\n",
      "¿Es numérico? True\n",
      "¿Es en minúsculas? True\n"
     ]
    }
   ],
   "source": [
    "texto = \"Python Lenguaje de Programación\"\n",
    "\n",
    "# Búsqueda de subcadenas\n",
    "posicion = texto.find(\"Programación\")      # 19\n",
    "ultima_posicion = texto.rfind(\"n\")        # 30\n",
    "contador = texto.count(\"n\")               # 3\n",
    "\n",
    "# Verificaciones booleanas\n",
    "es_alfanumerico = \"Python123\".isalnum()   # True\n",
    "es_alfabetico = \"Python\".isalpha()        # True\n",
    "es_numerico = \"123\".isdigit()             # True\n",
    "es_minusculas = \"python\".islower()        # True\n",
    "es_mayusculas = \"PYTHON\".isupper()        # True\n",
    "es_espacios = \"   \".isspace()             # True\n",
    "\n",
    "print(f\"Posición de 'Programación': {posicion}\")\n",
    "print(f\"Última posición de 'n': {ultima_posicion}\")\n",
    "print(f\"Contador de 'n': {contador}\")\n",
    "print(f\"¿Es alfanumérico? {es_alfanumerico}\")\n",
    "print(f\"¿Es alfabético? {es_alfabetico}\")\n",
    "print(f\"¿Es numérico? {es_numerico}\")\n",
    "print(f\"¿Es en minúsculas? {es_minusculas}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "2tektnZ5O7PS",
    "outputId": "5dba1788-4bf6-4b55-eb26-7bec8a129eeb"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cantidad de letras mayúsculas: 3\n"
     ]
    }
   ],
   "source": [
    "contadormayus = sum(1 for d in texto if d.isupper())\n",
    "\n",
    "print(\"Cantidad de letras mayúsculas:\", contador)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "2xl6nCZYPeq_"
   },
   "source": [
    "**División y unión**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "kOfd4SwMPhqy",
    "outputId": "f0b09e56-b478-4685-ca4b-5808752fec52"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dividido: ['Python', 'Java', 'C++', 'JavaScript']\n",
      "Dividido: ['Hola', 'mundo', 'Python']\n",
      "Unido: Python,Java,C++,JavaScript\n",
      "Unido: Hola-mundo-Python\n",
      "Unido: Línea1 Línea2 Línea3\n"
     ]
    }
   ],
   "source": [
    "# División (split)\n",
    "frase = \"Python,Java,C++,JavaScript\"\n",
    "lenguajes = frase.split(\",\")              # ['Python', 'Java', 'C++', 'JavaScript']\n",
    "\n",
    "texto = \"Hola mundo Python\"\n",
    "palabras = texto.split()                  # ['Hola', 'mundo', 'Python']\n",
    "\n",
    "lineas = \"Línea1\\nLínea2\\nLínea3\"\n",
    "lista_lineas = lineas.split(\"\\n\")         # ['Línea 1', 'Línea 2', 'Línea 3']\n",
    "\n",
    "# Unión (join)\n",
    "unido_comas = \",\".join(lenguajes)         # \"Python,Java,C++,JavaScript\"\n",
    "unido_guiones = \"-\".join(palabras)        # \"Hola-mundo-Python\"\n",
    "unido_espacios = \" \".join(lista_lineas)   # \"Línea 1 Línea 2 Línea 3\"\n",
    "\n",
    "print(f\"Dividido: {lenguajes}\")\n",
    "print(f\"Dividido: {palabras}\")\n",
    "print(f\"Unido: {unido_comas}\")\n",
    "print(f\"Unido: {unido_guiones}\")\n",
    "print(f\"Unido: {unido_espacios}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "FsetLDdrT11x"
   },
   "source": [
    "**Reemplazo y formateo**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "aCYItBPjTh5_",
    "outputId": "c4fd12a4-ffe3-4084-85c4-5356efc6226e"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Reemplazo: Me gusta Python y Python es genial\n",
      "Centrado:        Python       \n",
      "A la izquierda: Python*********\n",
      "A la derecha: *********Python\n",
      "Con ceros: 00042\n"
     ]
    }
   ],
   "source": [
    "texto = \"Me gusta Java y Java es genial\"\n",
    "\n",
    "# Reemplazo\n",
    "nuevo_texto = texto.replace(\"Java\", \"Python\")  # \"Me gusta Python y Python es genial\"\n",
    "\n",
    "reemplazo_limitado = texto.replace(\"Java\", \"Python\", 1)  # Solo el primero\n",
    "\n",
    "# Justificación\n",
    "centrado = \"Python\".center(20, \" \")       # \"-------Python-------\"\n",
    "izquierda = \"Python\".ljust(15, \"*\")       # \"Python*********\"\n",
    "derecha = \"Python\".rjust(15, \"*\")         # \"*********Python\"\n",
    "\n",
    "# Relleno con ceros\n",
    "numero = \"42\"\n",
    "con_ceros = numero.zfill(5)               # \"00042\"\n",
    "\n",
    "print(f\"Reemplazo: {nuevo_texto}\")\n",
    "print(f\"Centrado: {centrado}\")\n",
    "print(f\"A la izquierda: {izquierda}\")\n",
    "print(f\"A la derecha: {derecha}\")\n",
    "print(f\"Con ceros: {con_ceros}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "S4_7ZQehWehb"
   },
   "source": [
    "**F-String Básicas**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "aeO6U9FpV6C1",
    "outputId": "23f612eb-af52-4697-e6aa-0cd896d647d8"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Me llamo Ana y tengo 30 años\n",
      "Hola ANA!\n",
      "Sr./Sra. Ana, bienvenido/a\n"
     ]
    }
   ],
   "source": [
    "nombre = \"Ana\"\n",
    "edad = 30\n",
    "salario = 2500000\n",
    "\n",
    "# Formateo básico\n",
    "presentacion = f\"Me llamo {nombre} y tengo {edad} años\"\n",
    "\n",
    "# Expresiones dentro de f-strings\n",
    "saludo = f\"Hola {nombre.upper()}!\"                    # \"Hola ANA!\"\n",
    "calculado = f\"En 5 años tendré {edad + 5} años\"       # \"En 5 años tendré 35 años\"\n",
    "\n",
    "# Llamadas a funciones\n",
    "def obtener_titulo(nombre):\n",
    "    return f\"Sr./Sra. {nombre}\"\n",
    "\n",
    "titulo = f\"{obtener_titulo(nombre)}, bienvenido/a\"    # \"Sr./Sra. Ana, bienvenido/a\"\n",
    "\n",
    "print(presentacion)\n",
    "print(saludo)\n",
    "print(titulo)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "LVFE2UM-WkXn"
   },
   "source": [
    "# **Taller Practico con Strings**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "id": "rzKi_6txc4vl"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Phytonsito\n",
      "Wilfer Esneyder Echeverri Ramirez\n",
      "Univerisdad de Antioquia\n",
      "22 de octubre del 2025\n",
      "1. Smith, J. (2020). Machine Learning Fundamentals. \n",
      "2. García, M. (2021). Data Analysis Techniques. \n",
      "3. Lee, K. (2023). Python for Research. \n",
      "\n",
      "10.1000/182.v1\n"
     ]
    }
   ],
   "source": [
    "#Parte 1\n",
    "#Concatenar cadenas de texto\n",
    "\n",
    "# INSTRUCCIONES: Construye documentos académicos Usando tus datos\n",
    "titulo = \"Phytonsito\"\n",
    "autor = \"Wilfer Esneyder Echeverri Ramirez\"\n",
    "institucion = \"Univerisdad de Antioquia\"\n",
    "fecha = \"22 de octubre del 2025\"\n",
    "\n",
    "# 1. Construye el encabezado del documento Titulo, Autor, Institución, Fecha\n",
    "encabezado = titulo + \"\\n\" + autor + \"\\n\" + institucion + \"\\n\" + fecha\n",
    "\n",
    "print(encabezado)\n",
    "# 2. Construye una bibliografía del documento\n",
    "bibliografia = \"\"\n",
    "bibliografia += \"1. Smith, J. (2020). Machine Learning Fundamentals. \\n\" \n",
    "bibliografia += \"2. García, M. (2021). Data Analysis Techniques. \\n\" \n",
    "bibliografia += \"3. Lee, K. (2023). Python for Research. \\n\" \n",
    "print(bibliografia)\n",
    "\n",
    "# 3. Crea un DOI (10.1000/182.v1) concatenando partes\n",
    "prefijo = \"10.1000\"\n",
    "sufijo = \"182\"\n",
    "version = \"v1\"\n",
    "\n",
    "DOI = prefijo + \"/\" + sufijo + \".\" + version\n",
    "print(DOI)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "cbjhrw7rfszO",
    "outputId": "01cb41a6-780c-4165-e9eb-db718a56b032"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "----------SISTEMA UNIVERSITARIO----------\n",
      "Calificación:★★★★☆ (4.5/5)\n"
     ]
    }
   ],
   "source": [
    "# INSTRUCCIONES: Crea elementos visuales para interfaz\n",
    "separador = \"-\"\n",
    "encabezado = \"SISTEMA UNIVERSITARIO\"\n",
    "calificacion = \"★\"\n",
    "estrella_vacia= \"☆\"\n",
    "nota = 4.5\n",
    "\n",
    "encabezado1 = separador*10 + \"\" + encabezado + \"\" + separador*10\n",
    "print(encabezado1)\n",
    "\n",
    "print(f\"Calificación:{calificacion*int(nota)}{estrella_vacia*(5-int(nota))} ({nota}/5)\")\n",
    "#********** SISTEMA UNIVERSITARIO **********\n",
    "#Calificación: ★★★★☆ (4.5/5)\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "f2LYt2dri_Ww"
   },
   "outputs": [],
   "source": [
    "#Parte 3\n",
    "#Longitud de texto\n",
    "\n",
    "# INSTRUCCIONES: Analiza longitudes de textos universitarios\n",
    "resumen = '''El presente artículo expone los resultados de un estudio orientado al desarrollo de un modelo de machine learning para la predicción del comportamiento de\n",
    "consumo energético en entornos urbanos, utilizando técnicas avanzadas de análisis de datos. Se recopiló un conjunto de más de 500 000 registros provenientes de sensores\n",
    "inteligentes instalados en la red eléctrica de tres ciudades latinoamericanas. Mediante un proceso de limpieza, normalización y transformación de datos, se identificaron\n",
    " patrones relevantes asociados con variables como temperatura ambiental, hora del día y tipo de zona residencial.\n",
    "\n",
    "El análisis exploratorio permitió detectar correlaciones significativas y anomalías de consumo que fueron modeladas mediante algoritmos supervisados, incluyendo Random Forest,\n",
    " XGBoost y redes neuronales profundas (Deep Neural Networks). Los resultados experimentales mostraron que el modelo basado en XGBoost alcanzó la mayor precisión, con un R² de 0.94 y\n",
    "  un MAE promedio de 0.18, superando en un 12% a los métodos tradicionales de regresión lineal.\n",
    "\n",
    "Además, se desarrolló un tablero interactivo de visualización que permite monitorear en tiempo real las predicciones y el rendimiento energético por sector. Se concluye que la\n",
    " integración de técnicas de machine learning con sistemas de monitoreo urbano representa una herramienta estratégica para la optimización del uso de recursos y la planificación energética sostenible'''\n",
    "\n",
    "titulo = \"Predicción del consumo energético urbano mediante técnicas de análisis de datos y machine learning\"\n",
    "nombre_completo = \"María José Rodríguez Hernández\"\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "id": "1Qf-OLSmoa54"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "La palabra clave 'análisis de datos' aparece 1 vez/veces en el abstract.\n",
      "La palabra clave 'machine learning' aparece 2 vez/veces en el abstract.\n",
      "La palabra clave 'consumo energético' aparece 1 vez/veces en el abstract.\n",
      "La palabra clave 'modelos predictivos' NO aparece en el abstract.\n"
     ]
    }
   ],
   "source": [
    "#Parte 4\n",
    "#Verifica contenido en textos académicos\n",
    "# Palabras Clave en el resumen del punto anterior: Análisis de datos, Machine learning, Consumo energético, Modelos predictivos\n",
    "\n",
    "palabras_clave = [\"análisis de datos\", \"machine learning\", \"consumo energético\", \"modelos predictivos\"]\n",
    "# 1. Verifica si cada palabra clave está en el abstract y cuantas veces aparece\n",
    "for palabra in palabras_clave:\n",
    "    conteo = resumen.lower().count(palabra.lower())  # ignora mayúsculas/minúsculas\n",
    "    if conteo > 0:\n",
    "        print(f\"La palabra clave '{palabra}' aparece {conteo} vez/veces en el abstract.\")\n",
    "    else:\n",
    "        print(f\"La palabra clave '{palabra}' NO aparece en el abstract.\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "id": "reFG3jwsx613"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1. Nombre normalizado: Ana María García\n",
      "2. Título normalizado: Introducción A La Programación En Python\n",
      "3. Email institucional: ana.maría@universidad.edu\n"
     ]
    }
   ],
   "source": [
    "#Parte 5\n",
    "# INSTRUCCIONES: Normaliza datos de entrada de usuario\n",
    "entrada_usuario = \"  ana maría GARCÍA  \"\n",
    "titulo_libro = \"introducción a la PROGRAMACIÓN en PYTHON\"\n",
    "\n",
    "# 1. Normaliza el nombre: Primera letra mayúscula, resto minúsculas, sin espacios\n",
    "nombre_normalizado = entrada_usuario.title().strip()  # Completa la cadena\n",
    "print(\"1. Nombre normalizado:\", nombre_normalizado)\n",
    "\n",
    "# 2. Convierte el título del libro a formato título (cada palabra capitalizada)\n",
    "titulo_normalizado = titulo_libro.title()  # Completa\n",
    "print(\"2. Título normalizado:\", titulo_normalizado)\n",
    "\n",
    "# 3. Crea un email institucional: nombre.apellido@universidad.edu todo en minuscula\n",
    "partes_nombre = nombre_normalizado.split()\n",
    "email_institucional = f\"{partes_nombre[0]}.{partes_nombre[1]}@universidad.edu\".lower()  # Completa\n",
    "print(\"3. Email institucional:\", email_institucional)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "sZ01UCsZZLTM"
   },
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "authorship_tag": "ABX9TyO3yQqYgy5TXrQjwUZQ6wkE",
   "include_colab_link": true,
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
